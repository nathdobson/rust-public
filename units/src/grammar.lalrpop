use std::str::FromStr;
use crate::ast::{Expr, Opcode, Stmt, Block, UnitSet, UnitPart};
use lalrpop_util::ParseError;
use ustr::Ustr;

grammar;

pub Block: Block = {
    <Stmt*> => Block(<>),
}

pub Stmt: Stmt = {
    "let" <Ident> "=" <Expr> ";" => Stmt::Let(<>),
    "return" <Expr> ";" => Stmt::Return(<>),
}

pub Expr: Box<Expr> = {
    Expr ExprOp Factor => Box::new(Expr::Op(<>)),
    Factor,
};

ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

Factor: Box<Expr> = {
    Factor FactorOp UnitFactor => Box::new(Expr::Op(<>)),
    UnitFactor,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

UnitFactor: Box<Expr> = {
    Term UnitSet => Box::new(Expr::WithUnits(<>)),
    <t:Term> "as" <mut xs:(<UnitSet> "or")*> <x:UnitSet> => {
        xs.push(x);
        Box::new(Expr::AsUnits(t, xs))
    },
    Term,
}

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Ident => Box::new(Expr::Var(<>)),
    "(" <Expr> ")",
    <Ident> "(" <(<Expr> ",")*> ")" => Box::new(Expr::Call(<>)),
};

UnitPower: (Ustr, i32) = {
    Ident => (<>, 1),
}

UnitPart: UnitPart = {
    UnitPower+ => UnitPart(<>)
}

UnitSet: UnitSet = {
    UnitPart => UnitSet::Simple(<>),
    <UnitPart> "per" <UnitPart> => UnitSet::Fraction(<>),
}

Num: f64 = {
    r"[0-9]+(.[0-9]+)?" =>? f64::from_str(<>)
        .map_err(|_| ParseError::User {
          error: "number is too big"
        })
};

Ident: Ustr = {
    r"[[:alpha:]]\w*" => Ustr::from(<>),
}
